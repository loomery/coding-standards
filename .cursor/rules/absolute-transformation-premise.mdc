---
description:
globs:
alwaysApply: true
---
# Absolute Transformation Premise (APP)

## Description
Micah Martin's Absolute Transformation Premise - an improvement on the Transformation Priority Premise that provides objective heuristics to compare code quality by assigning mass values to code components.

## Core Concept
The APP assigns "mass" to different code components. Lower total mass indicates better, simpler code. The premise is that code with less mass is objectively better than code with more mass.

## The Six Components (with Mass Values)

### 1. Constant (Mass: 1)
- Literal values in code
- Examples: `5`, `"hello"`, `true`, `[]`
- Lowest mass - preferred building block

### 2. Binding/Scalar (Mass: 2)
- Variables, parameters, local names
- Examples: `amount`, `userName`, `result`
- Names that refer to values

### 3. Invocation (Mass: 3)
- Function/method calls
- Examples: `calculate()`, `user.getName()`, `Math.max(a, b)`
- Calling existing functionality

### 4. Conditional (Mass: 4)
- Control flow decisions
- Examples: `if`, `switch`, `case`, `cond`, `?:`
- Branching logic

### 5. Loop (Mass: 5)
- Iteration constructs
- Examples: `while`, `for`, `forEach`, `map`
- Repetitive execution

### 6. Assignment (Mass: 6)
- Mutating variables (highest mass)
- Examples: `x = 5`, `count++`, `list.add(item)`
- State changes - most complex

## Calculation Rules

### Total Mass = Sum of All Components
```
Total Mass = (constants × 1) + (bindings × 2) + (invocations × 3) +
             (conditionals × 4) + (loops × 5) + (assignments × 6)
```

### Comparison Guidelines
- **Lower mass = Better code**
- **Functional style naturally scores lower** (no assignments/loops)
- **Immutable approaches preferred** over mutable ones
- **Simple expressions preferred** over complex control structures

## Integration with TDD and Simple Design

### With TDD Process
- **Red Phase**: Focus on passing tests (mass irrelevant)
- **Green Phase**: Write minimal code (naturally low mass)
- **Refactor Phase**: Apply APP to guide improvements toward lower mass

### With Simple Design Rules
1. **Tests Pass** (Rule #1) - Always highest priority
2. **Reveals Intent** (Rule #2) - May increase mass for clarity
3. **No Duplication** (Rule #3) - Extract to reduce mass
4. **Fewest Elements** (Rule #4) - Aligns with APP's low mass goal

### Priority Resolution
- **Simple Design Rule #2 trumps APP** - Clarity over low mass
- **Use APP within refactor phase** to guide toward simpler solutions
- **APP helps choose between equivalent clear solutions**

## Practical Application

### Example Comparison
```typescript
// Higher Mass Version (Mass: 42)
function processItems(items: string[]): string[] {
  const result: string[] = [];           // binding(2) + constant(1) = 3
  for (let i = 0; i < items.length; i++) { // binding(2) + loop(5) + invocation(3) = 10
    if (items[i].length > 3) {           // conditional(4) + invocation(3) = 7
      result.push(items[i].toUpperCase()); // invocation(3) + invocation(3) + assignment(6) = 12
    }
  }
  return result;                         // binding(2) = 2
}
// Total: 34

// Lower Mass Version (Mass: 28)
function processItems(items: string[]): string[] {
  return items                           // binding(2)
    .filter(item => item.length > 3)     // invocation(3) + binding(2) + invocation(3) + constant(1) = 9
    .map(item => item.toUpperCase());    // invocation(3) + binding(2) + invocation(3) = 8
}
// Total: 22
```

### Language Considerations
- **Functional languages** (Clojure, Haskell) naturally score lower
- **Imperative languages** (Java, C#) may need adjusted weights
- **Consider language idioms** when applying APP

## Guidelines for Use

### When to Apply APP
- **During refactoring** to choose between working solutions
- **When comparing algorithms** of similar functionality
- **To guide toward simpler implementations**
- **Not during initial TDD red/green phases**

### When NOT to Use APP
- **Never sacrifice clarity** for lower mass
- **Don't optimize prematurely** based on mass alone
- **Performance requirements** may override mass considerations
- **Domain complexity** may require higher mass solutions

### Red Flags
- **Obsessing over mass** during initial development
- **Sacrificing readability** for lower scores
- **Ignoring performance** implications
- **Applying rigidly** without context

## Benefits
- **Objective measurement** of code complexity
- **Guides toward functional approaches**
- **Encourages immutability**
- **Complements other design principles**
- **Helps compare equivalent solutions**

## Limitations
- **Mass ≠ Quality** in all contexts
- **Language-dependent** effectiveness
- **May conflict with readability**
- **Performance implications** not considered
- **Domain complexity** not factored

## Remember
- APP is a **tool, not a rule**
- **Context matters** more than absolute scores
- **Combine with other principles** for best results
- **Lower mass is generally better**, but not always
- **Use during refactoring**, not initial development
